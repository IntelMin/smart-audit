"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@stablelib+hmac@1.0.1";
exports.ids = ["vendor-chunks/@stablelib+hmac@1.0.1"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@stablelib+hmac@1.0.1/node_modules/@stablelib/hmac/lib/hmac.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/.pnpm/@stablelib+hmac@1.0.1/node_modules/@stablelib/hmac/lib/hmac.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n/**\n * Package hmac implements HMAC algorithm.\n */ var hash_1 = __webpack_require__(/*! @stablelib/hash */ \"(ssr)/./node_modules/.pnpm/@stablelib+hash@1.0.1/node_modules/@stablelib/hash/lib/hash.js\");\nvar constant_time_1 = __webpack_require__(/*! @stablelib/constant-time */ \"(ssr)/./node_modules/.pnpm/@stablelib+constant-time@1.0.1/node_modules/@stablelib/constant-time/lib/constant-time.js\");\nvar wipe_1 = __webpack_require__(/*! @stablelib/wipe */ \"(ssr)/./node_modules/.pnpm/@stablelib+wipe@1.0.1/node_modules/@stablelib/wipe/lib/wipe.js\");\n/**\n *  HMAC implements hash-based message authentication algorithm.\n */ var HMAC = /** @class */ function() {\n    /**\n     * Constructs a new HMAC with the given Hash and secret key.\n     */ function HMAC(hash, key) {\n        this._finished = false; // true if HMAC was finalized\n        // Initialize inner and outer hashes.\n        this._inner = new hash();\n        this._outer = new hash();\n        // Set block and digest sizes for this HMAC\n        // instance to values from the hash.\n        this.blockSize = this._outer.blockSize;\n        this.digestLength = this._outer.digestLength;\n        // Pad temporary stores a key (or its hash) padded with zeroes.\n        var pad = new Uint8Array(this.blockSize);\n        if (key.length > this.blockSize) {\n            // If key is bigger than hash block size, it must be\n            // hashed and this hash is used as a key instead.\n            this._inner.update(key).finish(pad).clean();\n        } else {\n            // Otherwise, copy the key into pad.\n            pad.set(key);\n        }\n        // Now two different keys are derived from padded key\n        // by xoring a different byte value to each.\n        // To make inner hash key, xor byte 0x36 into pad.\n        for(var i = 0; i < pad.length; i++){\n            pad[i] ^= 0x36;\n        }\n        // Update inner hash with the result.\n        this._inner.update(pad);\n        // To make outer hash key, xor byte 0x5c into pad.\n        // But since we already xored 0x36 there, we must\n        // first undo this by xoring it again.\n        for(var i = 0; i < pad.length; i++){\n            pad[i] ^= 0x36 ^ 0x5c;\n        }\n        // Update outer hash with the result.\n        this._outer.update(pad);\n        // Save states of both hashes, so that we can quickly restore\n        // them later in reset() without the need to remember the actual\n        // key and perform this initialization again.\n        if (hash_1.isSerializableHash(this._inner) && hash_1.isSerializableHash(this._outer)) {\n            this._innerKeyedState = this._inner.saveState();\n            this._outerKeyedState = this._outer.saveState();\n        }\n        // Clean pad.\n        wipe_1.wipe(pad);\n    }\n    /**\n     * Returns HMAC state to the state initialized with key\n     * to make it possible to run HMAC over the other data with the same\n     * key without creating a new instance.\n     */ HMAC.prototype.reset = function() {\n        if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {\n            throw new Error(\"hmac: can't reset() because hash doesn't implement restoreState()\");\n        }\n        // Restore keyed states of inner and outer hashes.\n        this._inner.restoreState(this._innerKeyedState);\n        this._outer.restoreState(this._outerKeyedState);\n        this._finished = false;\n        return this;\n    };\n    /**\n     * Cleans HMAC state.\n     */ HMAC.prototype.clean = function() {\n        if (hash_1.isSerializableHash(this._inner)) {\n            this._inner.cleanSavedState(this._innerKeyedState);\n        }\n        if (hash_1.isSerializableHash(this._outer)) {\n            this._outer.cleanSavedState(this._outerKeyedState);\n        }\n        this._inner.clean();\n        this._outer.clean();\n    };\n    /**\n     * Updates state with provided data.\n     */ HMAC.prototype.update = function(data) {\n        this._inner.update(data);\n        return this;\n    };\n    /**\n     * Finalizes HMAC and puts the result in out.\n     */ HMAC.prototype.finish = function(out) {\n        if (this._finished) {\n            // If HMAC was finalized, outer hash is also finalized,\n            // so it produces the same digest it produced when it\n            // was finalized.\n            this._outer.finish(out);\n            return this;\n        }\n        // Finalize inner hash and store the result temporarily.\n        this._inner.finish(out);\n        // Update outer hash with digest of inner hash and and finalize it.\n        this._outer.update(out.subarray(0, this.digestLength)).finish(out);\n        this._finished = true;\n        return this;\n    };\n    /**\n     * Returns the computed message authentication code.\n     */ HMAC.prototype.digest = function() {\n        var out = new Uint8Array(this.digestLength);\n        this.finish(out);\n        return out;\n    };\n    /**\n     * Saves HMAC state.\n     * This function is needed for PBKDF2 optimization.\n     */ HMAC.prototype.saveState = function() {\n        if (!hash_1.isSerializableHash(this._inner)) {\n            throw new Error(\"hmac: can't saveState() because hash doesn't implement it\");\n        }\n        return this._inner.saveState();\n    };\n    HMAC.prototype.restoreState = function(savedState) {\n        if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {\n            throw new Error(\"hmac: can't restoreState() because hash doesn't implement it\");\n        }\n        this._inner.restoreState(savedState);\n        this._outer.restoreState(this._outerKeyedState);\n        this._finished = false;\n        return this;\n    };\n    HMAC.prototype.cleanSavedState = function(savedState) {\n        if (!hash_1.isSerializableHash(this._inner)) {\n            throw new Error(\"hmac: can't cleanSavedState() because hash doesn't implement it\");\n        }\n        this._inner.cleanSavedState(savedState);\n    };\n    return HMAC;\n}();\nexports.HMAC = HMAC;\n/**\n * Returns HMAC using the given hash constructor for the key over data.\n */ function hmac(hash, key, data) {\n    var h = new HMAC(hash, key);\n    h.update(data);\n    var digest = h.digest();\n    h.clean();\n    return digest;\n}\nexports.hmac = hmac;\n/**\n * Returns true if two HMAC digests are equal.\n * Uses constant-time comparison to avoid leaking timing information.\n *\n * Example:\n *\n *    const receivedDigest = ...\n *    const realDigest = hmac(SHA256, key, data);\n *    if (!equal(receivedDigest, realDigest)) {\n *        throw new Error(\"Authentication error\");\n *    }\n */ exports.equal = constant_time_1.equal; //# sourceMappingURL=hmac.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHN0YWJsZWxpYitobWFjQDEuMC4xL25vZGVfbW9kdWxlcy9Ac3RhYmxlbGliL2htYWMvbGliL2htYWMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixzQ0FBc0M7QUFDdEMsNkNBQTZDO0FBQzdDQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3RDs7Q0FFQyxHQUNELElBQUlDLFNBQVNDLG1CQUFPQSxDQUFDLGtIQUFpQjtBQUN0QyxJQUFJQyxrQkFBa0JELG1CQUFPQSxDQUFDLHNKQUEwQjtBQUN4RCxJQUFJRSxTQUFTRixtQkFBT0EsQ0FBQyxrSEFBaUI7QUFDdEM7O0NBRUMsR0FDRCxJQUFJRyxPQUFPLFdBQVcsR0FBSTtJQUN0Qjs7S0FFQyxHQUNELFNBQVNBLEtBQUtDLElBQUksRUFBRUMsR0FBRztRQUNuQixJQUFJLENBQUNDLFNBQVMsR0FBRyxPQUFPLDZCQUE2QjtRQUNyRCxxQ0FBcUM7UUFDckMsSUFBSSxDQUFDQyxNQUFNLEdBQUcsSUFBSUg7UUFDbEIsSUFBSSxDQUFDSSxNQUFNLEdBQUcsSUFBSUo7UUFDbEIsMkNBQTJDO1FBQzNDLG9DQUFvQztRQUNwQyxJQUFJLENBQUNLLFNBQVMsR0FBRyxJQUFJLENBQUNELE1BQU0sQ0FBQ0MsU0FBUztRQUN0QyxJQUFJLENBQUNDLFlBQVksR0FBRyxJQUFJLENBQUNGLE1BQU0sQ0FBQ0UsWUFBWTtRQUM1QywrREFBK0Q7UUFDL0QsSUFBSUMsTUFBTSxJQUFJQyxXQUFXLElBQUksQ0FBQ0gsU0FBUztRQUN2QyxJQUFJSixJQUFJUSxNQUFNLEdBQUcsSUFBSSxDQUFDSixTQUFTLEVBQUU7WUFDN0Isb0RBQW9EO1lBQ3BELGlEQUFpRDtZQUNqRCxJQUFJLENBQUNGLE1BQU0sQ0FBQ08sTUFBTSxDQUFDVCxLQUFLVSxNQUFNLENBQUNKLEtBQUtLLEtBQUs7UUFDN0MsT0FDSztZQUNELG9DQUFvQztZQUNwQ0wsSUFBSU0sR0FBRyxDQUFDWjtR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QU85QjtBQUNYO0FBQ0FOLFlBQVksR0FBR007QUFDZjs7Q0FFQyxHQUNELFNBQVMrQixLQUFLOUIsSUFBSSxFQUFFQyxHQUFHLEVBQUV3QixJQUFJO0lBQ3pCLElBQUlNLElBQUksSUFBSWhDLEtBQUtDLE1BQU1DO0lBQ3ZCOEIsRUFBRXJCLE1BQU0sQ0FBQ2U7SUFDVCxJQUFJRyxTQUFTRyxFQUFFSCxNQUFNO0lBQ3JCRyxFQUFFbkIsS0FBSztJQUNQLE9BQU9nQjtBQUNYO0FBQ0FuQyxZQUFZLEdBQUdxQztBQUNmOzs7Ozs7Ozs7OztDQVdDLEdBQ0RyQyxhQUFhLEdBQUdJLGdCQUFnQm1DLEtBQUssRUFDckMsZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtYXVkaXQvLi9ub2RlX21vZHVsZXMvLnBucG0vQHN0YWJsZWxpYitobWFjQDEuMC4xL25vZGVfbW9kdWxlcy9Ac3RhYmxlbGliL2htYWMvbGliL2htYWMuanM/ODJiNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAoQykgMjAxNiBEbWl0cnkgQ2hlc3RueWtoXG4vLyBNSVQgTGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBmb3IgZGV0YWlscy5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogUGFja2FnZSBobWFjIGltcGxlbWVudHMgSE1BQyBhbGdvcml0aG0uXG4gKi9cbnZhciBoYXNoXzEgPSByZXF1aXJlKFwiQHN0YWJsZWxpYi9oYXNoXCIpO1xudmFyIGNvbnN0YW50X3RpbWVfMSA9IHJlcXVpcmUoXCJAc3RhYmxlbGliL2NvbnN0YW50LXRpbWVcIik7XG52YXIgd2lwZV8xID0gcmVxdWlyZShcIkBzdGFibGVsaWIvd2lwZVwiKTtcbi8qKlxuICogIEhNQUMgaW1wbGVtZW50cyBoYXNoLWJhc2VkIG1lc3NhZ2UgYXV0aGVudGljYXRpb24gYWxnb3JpdGhtLlxuICovXG52YXIgSE1BQyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IEhNQUMgd2l0aCB0aGUgZ2l2ZW4gSGFzaCBhbmQgc2VjcmV0IGtleS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBITUFDKGhhc2gsIGtleSkge1xuICAgICAgICB0aGlzLl9maW5pc2hlZCA9IGZhbHNlOyAvLyB0cnVlIGlmIEhNQUMgd2FzIGZpbmFsaXplZFxuICAgICAgICAvLyBJbml0aWFsaXplIGlubmVyIGFuZCBvdXRlciBoYXNoZXMuXG4gICAgICAgIHRoaXMuX2lubmVyID0gbmV3IGhhc2goKTtcbiAgICAgICAgdGhpcy5fb3V0ZXIgPSBuZXcgaGFzaCgpO1xuICAgICAgICAvLyBTZXQgYmxvY2sgYW5kIGRpZ2VzdCBzaXplcyBmb3IgdGhpcyBITUFDXG4gICAgICAgIC8vIGluc3RhbmNlIHRvIHZhbHVlcyBmcm9tIHRoZSBoYXNoLlxuICAgICAgICB0aGlzLmJsb2NrU2l6ZSA9IHRoaXMuX291dGVyLmJsb2NrU2l6ZTtcbiAgICAgICAgdGhpcy5kaWdlc3RMZW5ndGggPSB0aGlzLl9vdXRlci5kaWdlc3RMZW5ndGg7XG4gICAgICAgIC8vIFBhZCB0ZW1wb3Jhcnkgc3RvcmVzIGEga2V5IChvciBpdHMgaGFzaCkgcGFkZGVkIHdpdGggemVyb2VzLlxuICAgICAgICB2YXIgcGFkID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5ibG9ja1NpemUpO1xuICAgICAgICBpZiAoa2V5Lmxlbmd0aCA+IHRoaXMuYmxvY2tTaXplKSB7XG4gICAgICAgICAgICAvLyBJZiBrZXkgaXMgYmlnZ2VyIHRoYW4gaGFzaCBibG9jayBzaXplLCBpdCBtdXN0IGJlXG4gICAgICAgICAgICAvLyBoYXNoZWQgYW5kIHRoaXMgaGFzaCBpcyB1c2VkIGFzIGEga2V5IGluc3RlYWQuXG4gICAgICAgICAgICB0aGlzLl9pbm5lci51cGRhdGUoa2V5KS5maW5pc2gocGFkKS5jbGVhbigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBjb3B5IHRoZSBrZXkgaW50byBwYWQuXG4gICAgICAgICAgICBwYWQuc2V0KGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm93IHR3byBkaWZmZXJlbnQga2V5cyBhcmUgZGVyaXZlZCBmcm9tIHBhZGRlZCBrZXlcbiAgICAgICAgLy8gYnkgeG9yaW5nIGEgZGlmZmVyZW50IGJ5dGUgdmFsdWUgdG8gZWFjaC5cbiAgICAgICAgLy8gVG8gbWFrZSBpbm5lciBoYXNoIGtleSwgeG9yIGJ5dGUgMHgzNiBpbnRvIHBhZC5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHBhZFtpXSBePSAweDM2O1xuICAgICAgICB9XG4gICAgICAgIC8vIFVwZGF0ZSBpbm5lciBoYXNoIHdpdGggdGhlIHJlc3VsdC5cbiAgICAgICAgdGhpcy5faW5uZXIudXBkYXRlKHBhZCk7XG4gICAgICAgIC8vIFRvIG1ha2Ugb3V0ZXIgaGFzaCBrZXksIHhvciBieXRlIDB4NWMgaW50byBwYWQuXG4gICAgICAgIC8vIEJ1dCBzaW5jZSB3ZSBhbHJlYWR5IHhvcmVkIDB4MzYgdGhlcmUsIHdlIG11c3RcbiAgICAgICAgLy8gZmlyc3QgdW5kbyB0aGlzIGJ5IHhvcmluZyBpdCBhZ2Fpbi5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHBhZFtpXSBePSAweDM2IF4gMHg1YztcbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGUgb3V0ZXIgaGFzaCB3aXRoIHRoZSByZXN1bHQuXG4gICAgICAgIHRoaXMuX291dGVyLnVwZGF0ZShwYWQpO1xuICAgICAgICAvLyBTYXZlIHN0YXRlcyBvZiBib3RoIGhhc2hlcywgc28gdGhhdCB3ZSBjYW4gcXVpY2tseSByZXN0b3JlXG4gICAgICAgIC8vIHRoZW0gbGF0ZXIgaW4gcmVzZXQoKSB3aXRob3V0IHRoZSBuZWVkIHRvIHJlbWVtYmVyIHRoZSBhY3R1YWxcbiAgICAgICAgLy8ga2V5IGFuZCBwZXJmb3JtIHRoaXMgaW5pdGlhbGl6YXRpb24gYWdhaW4uXG4gICAgICAgIGlmIChoYXNoXzEuaXNTZXJpYWxpemFibGVIYXNoKHRoaXMuX2lubmVyKSAmJiBoYXNoXzEuaXNTZXJpYWxpemFibGVIYXNoKHRoaXMuX291dGVyKSkge1xuICAgICAgICAgICAgdGhpcy5faW5uZXJLZXllZFN0YXRlID0gdGhpcy5faW5uZXIuc2F2ZVN0YXRlKCk7XG4gICAgICAgICAgICB0aGlzLl9vdXRlcktleWVkU3RhdGUgPSB0aGlzLl9vdXRlci5zYXZlU3RhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDbGVhbiBwYWQuXG4gICAgICAgIHdpcGVfMS53aXBlKHBhZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgSE1BQyBzdGF0ZSB0byB0aGUgc3RhdGUgaW5pdGlhbGl6ZWQgd2l0aCBrZXlcbiAgICAgKiB0byBtYWtlIGl0IHBvc3NpYmxlIHRvIHJ1biBITUFDIG92ZXIgdGhlIG90aGVyIGRhdGEgd2l0aCB0aGUgc2FtZVxuICAgICAqIGtleSB3aXRob3V0IGNyZWF0aW5nIGEgbmV3IGluc3RhbmNlLlxuICAgICAqL1xuICAgIEhNQUMucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWhhc2hfMS5pc1NlcmlhbGl6YWJsZUhhc2godGhpcy5faW5uZXIpIHx8ICFoYXNoXzEuaXNTZXJpYWxpemFibGVIYXNoKHRoaXMuX291dGVyKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaG1hYzogY2FuJ3QgcmVzZXQoKSBiZWNhdXNlIGhhc2ggZG9lc24ndCBpbXBsZW1lbnQgcmVzdG9yZVN0YXRlKClcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVzdG9yZSBrZXllZCBzdGF0ZXMgb2YgaW5uZXIgYW5kIG91dGVyIGhhc2hlcy5cbiAgICAgICAgdGhpcy5faW5uZXIucmVzdG9yZVN0YXRlKHRoaXMuX2lubmVyS2V5ZWRTdGF0ZSk7XG4gICAgICAgIHRoaXMuX291dGVyLnJlc3RvcmVTdGF0ZSh0aGlzLl9vdXRlcktleWVkU3RhdGUpO1xuICAgICAgICB0aGlzLl9maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENsZWFucyBITUFDIHN0YXRlLlxuICAgICAqL1xuICAgIEhNQUMucHJvdG90eXBlLmNsZWFuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaGFzaF8xLmlzU2VyaWFsaXphYmxlSGFzaCh0aGlzLl9pbm5lcikpIHtcbiAgICAgICAgICAgIHRoaXMuX2lubmVyLmNsZWFuU2F2ZWRTdGF0ZSh0aGlzLl9pbm5lcktleWVkU3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNoXzEuaXNTZXJpYWxpemFibGVIYXNoKHRoaXMuX291dGVyKSkge1xuICAgICAgICAgICAgdGhpcy5fb3V0ZXIuY2xlYW5TYXZlZFN0YXRlKHRoaXMuX291dGVyS2V5ZWRTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faW5uZXIuY2xlYW4oKTtcbiAgICAgICAgdGhpcy5fb3V0ZXIuY2xlYW4oKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgc3RhdGUgd2l0aCBwcm92aWRlZCBkYXRhLlxuICAgICAqL1xuICAgIEhNQUMucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHRoaXMuX2lubmVyLnVwZGF0ZShkYXRhKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGaW5hbGl6ZXMgSE1BQyBhbmQgcHV0cyB0aGUgcmVzdWx0IGluIG91dC5cbiAgICAgKi9cbiAgICBITUFDLnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbiAob3V0KSB7XG4gICAgICAgIGlmICh0aGlzLl9maW5pc2hlZCkge1xuICAgICAgICAgICAgLy8gSWYgSE1BQyB3YXMgZmluYWxpemVkLCBvdXRlciBoYXNoIGlzIGFsc28gZmluYWxpemVkLFxuICAgICAgICAgICAgLy8gc28gaXQgcHJvZHVjZXMgdGhlIHNhbWUgZGlnZXN0IGl0IHByb2R1Y2VkIHdoZW4gaXRcbiAgICAgICAgICAgIC8vIHdhcyBmaW5hbGl6ZWQuXG4gICAgICAgICAgICB0aGlzLl9vdXRlci5maW5pc2gob3V0KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpbmFsaXplIGlubmVyIGhhc2ggYW5kIHN0b3JlIHRoZSByZXN1bHQgdGVtcG9yYXJpbHkuXG4gICAgICAgIHRoaXMuX2lubmVyLmZpbmlzaChvdXQpO1xuICAgICAgICAvLyBVcGRhdGUgb3V0ZXIgaGFzaCB3aXRoIGRpZ2VzdCBvZiBpbm5lciBoYXNoIGFuZCBhbmQgZmluYWxpemUgaXQuXG4gICAgICAgIHRoaXMuX291dGVyLnVwZGF0ZShvdXQuc3ViYXJyYXkoMCwgdGhpcy5kaWdlc3RMZW5ndGgpKS5maW5pc2gob3V0KTtcbiAgICAgICAgdGhpcy5fZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvbXB1dGVkIG1lc3NhZ2UgYXV0aGVudGljYXRpb24gY29kZS5cbiAgICAgKi9cbiAgICBITUFDLnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvdXQgPSBuZXcgVWludDhBcnJheSh0aGlzLmRpZ2VzdExlbmd0aCk7XG4gICAgICAgIHRoaXMuZmluaXNoKG91dCk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTYXZlcyBITUFDIHN0YXRlLlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgbmVlZGVkIGZvciBQQktERjIgb3B0aW1pemF0aW9uLlxuICAgICAqL1xuICAgIEhNQUMucHJvdG90eXBlLnNhdmVTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFoYXNoXzEuaXNTZXJpYWxpemFibGVIYXNoKHRoaXMuX2lubmVyKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaG1hYzogY2FuJ3Qgc2F2ZVN0YXRlKCkgYmVjYXVzZSBoYXNoIGRvZXNuJ3QgaW1wbGVtZW50IGl0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9pbm5lci5zYXZlU3RhdGUoKTtcbiAgICB9O1xuICAgIEhNQUMucHJvdG90eXBlLnJlc3RvcmVTdGF0ZSA9IGZ1bmN0aW9uIChzYXZlZFN0YXRlKSB7XG4gICAgICAgIGlmICghaGFzaF8xLmlzU2VyaWFsaXphYmxlSGFzaCh0aGlzLl9pbm5lcikgfHwgIWhhc2hfMS5pc1NlcmlhbGl6YWJsZUhhc2godGhpcy5fb3V0ZXIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJobWFjOiBjYW4ndCByZXN0b3JlU3RhdGUoKSBiZWNhdXNlIGhhc2ggZG9lc24ndCBpbXBsZW1lbnQgaXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faW5uZXIucmVzdG9yZVN0YXRlKHNhdmVkU3RhdGUpO1xuICAgICAgICB0aGlzLl9vdXRlci5yZXN0b3JlU3RhdGUodGhpcy5fb3V0ZXJLZXllZFN0YXRlKTtcbiAgICAgICAgdGhpcy5fZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBITUFDLnByb3RvdHlwZS5jbGVhblNhdmVkU3RhdGUgPSBmdW5jdGlvbiAoc2F2ZWRTdGF0ZSkge1xuICAgICAgICBpZiAoIWhhc2hfMS5pc1NlcmlhbGl6YWJsZUhhc2godGhpcy5faW5uZXIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJobWFjOiBjYW4ndCBjbGVhblNhdmVkU3RhdGUoKSBiZWNhdXNlIGhhc2ggZG9lc24ndCBpbXBsZW1lbnQgaXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faW5uZXIuY2xlYW5TYXZlZFN0YXRlKHNhdmVkU3RhdGUpO1xuICAgIH07XG4gICAgcmV0dXJuIEhNQUM7XG59KCkpO1xuZXhwb3J0cy5ITUFDID0gSE1BQztcbi8qKlxuICogUmV0dXJucyBITUFDIHVzaW5nIHRoZSBnaXZlbiBoYXNoIGNvbnN0cnVjdG9yIGZvciB0aGUga2V5IG92ZXIgZGF0YS5cbiAqL1xuZnVuY3Rpb24gaG1hYyhoYXNoLCBrZXksIGRhdGEpIHtcbiAgICB2YXIgaCA9IG5ldyBITUFDKGhhc2gsIGtleSk7XG4gICAgaC51cGRhdGUoZGF0YSk7XG4gICAgdmFyIGRpZ2VzdCA9IGguZGlnZXN0KCk7XG4gICAgaC5jbGVhbigpO1xuICAgIHJldHVybiBkaWdlc3Q7XG59XG5leHBvcnRzLmhtYWMgPSBobWFjO1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdHdvIEhNQUMgZGlnZXN0cyBhcmUgZXF1YWwuXG4gKiBVc2VzIGNvbnN0YW50LXRpbWUgY29tcGFyaXNvbiB0byBhdm9pZCBsZWFraW5nIHRpbWluZyBpbmZvcm1hdGlvbi5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgIGNvbnN0IHJlY2VpdmVkRGlnZXN0ID0gLi4uXG4gKiAgICBjb25zdCByZWFsRGlnZXN0ID0gaG1hYyhTSEEyNTYsIGtleSwgZGF0YSk7XG4gKiAgICBpZiAoIWVxdWFsKHJlY2VpdmVkRGlnZXN0LCByZWFsRGlnZXN0KSkge1xuICogICAgICAgIHRocm93IG5ldyBFcnJvcihcIkF1dGhlbnRpY2F0aW9uIGVycm9yXCIpO1xuICogICAgfVxuICovXG5leHBvcnRzLmVxdWFsID0gY29uc3RhbnRfdGltZV8xLmVxdWFsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aG1hYy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJoYXNoXzEiLCJyZXF1aXJlIiwiY29uc3RhbnRfdGltZV8xIiwid2lwZV8xIiwiSE1BQyIsImhhc2giLCJrZXkiLCJfZmluaXNoZWQiLCJfaW5uZXIiLCJfb3V0ZXIiLCJibG9ja1NpemUiLCJkaWdlc3RMZW5ndGgiLCJwYWQiLCJVaW50OEFycmF5IiwibGVuZ3RoIiwidXBkYXRlIiwiZmluaXNoIiwiY2xlYW4iLCJzZXQiLCJpIiwiaXNTZXJpYWxpemFibGVIYXNoIiwiX2lubmVyS2V5ZWRTdGF0ZSIsInNhdmVTdGF0ZSIsIl9vdXRlcktleWVkU3RhdGUiLCJ3aXBlIiwicHJvdG90eXBlIiwicmVzZXQiLCJFcnJvciIsInJlc3RvcmVTdGF0ZSIsImNsZWFuU2F2ZWRTdGF0ZSIsImRhdGEiLCJvdXQiLCJzdWJhcnJheSIsImRpZ2VzdCIsInNhdmVkU3RhdGUiLCJobWFjIiwiaCIsImVxdWFsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@stablelib+hmac@1.0.1/node_modules/@stablelib/hmac/lib/hmac.js\n");

/***/ })

};
;