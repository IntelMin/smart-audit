{"time":1706377583443,"data":[{"function_name":"mintToken","vulnerability":"Arbitrary Minting","criticism":"The criticism provided is accurate in recognizing that the ability to mint tokens is not a vulnerability per se, but a feature that could be misused if the contract owner acts maliciously. The severity score should be higher if the mint function lacks proper checks and balances, as it could lead to significant inflation of the token supply and devaluation of the token. Profitability is correctly scored as low for external attackers, but it could be high for the owner if the minting is not aligned with the project's rules or intentions.","correctness":7,"severity":"INFO","profitability":0,"reason":"The '_transferWithTax' function calls '_swapTax', which interacts with external contracts (Uniswap Router). This can potentially allow reentrancy attacks because the 'inSwap' modifier sets 'inSwap' to true only after the external calls are made. An attacker could create a pair contract that calls back into the 'transfer' or 'transferFrom' while 'inSwap' is still false, bypassing the reentrancy guard.","code":"function _transferWithTax( address from, address to, uint256 amount ) internal {...}","final_score":5,"mitigation":"The '_transferWithTax' function calls '_swapTax', which interacts with external contracts (Uniswap Router). This can potentially allow reentrancy attacks because the 'inSwap' modifier sets 'inSwap' to true only after the external calls are made. An attacker could create a pair contract that calls back into the 'transfer' or 'transferFrom' while 'inSwap' is still false, bypassing the reentrancy guard.","title":"Arbitrary Minting"},{"function_name":"approve","vulnerability":"Race condition (front-running)","criticism":"The criticism is somewhat misleading. The approve function does indeed have a potential race condition vulnerability, but the explanation provided is incorrect. The check in the function is intended to prevent changing an allowance from a non-zero value to another non-zero value without first setting it to zero. This is a mitigation against the known ERC20 approve/allowance race condition, but it does not eliminate the risk of front-running attacks entirely. The severity could be higher if the token contract is widely used, as front-running can lead to financial losses.","correctness":5,"severity":"INFO","profitability":3,"reason":"The '_swapTax' function within the 'swapping' modifier does not have a limit on the number of tokens it attempts to swap. If the 'swapThreshold' is set too low and there are many small transfers, this could lead to high gas costs and potentially block the processing of transactions due to hitting the block gas limit, resulting in a denial of service.","code":"function _swapTax() internal swapping {...}","final_score":4.25,"mitigation":"The '_swapTax' function within the 'swapping' modifier does not have a limit on the number of tokens it attempts to swap. If the 'swapThreshold' is set too low and there are many small transfers, this could lead to high gas costs and potentially block the processing of transactions due to hitting the block gas limit, resulting in a denial of service.","title":"Race condition (front-running)"},{"function_name":"transferFrom","vulnerability":"Unchecked Transfer","criticism":"The criticism is partially correct; however, the Ethereum protocol ensures that tokens cannot be transferred to an invalid address. The address must be a valid Ethereum address; otherwise, the transaction will fail. The severity and profitability are correctly scored as low because the risk of loss due to sending to an incorrect, yet valid, address is a user error rather than a vulnerability in the code.","correctness":5,"severity":"INFO","profitability":0,"reason":"The 'setTaxFee' function does not validate individual fee values except for their sum. An attacker with the DEFAULT_ADMIN_ROLE could set very high individual fee values that overflow when summed together, resulting in a low total fee due to overflow. This could be exploited to set extremely high fees and drain tokens during transfers.","code":"function setTaxFee( uint256 guardianFee, uint256 liquidityFee, uint256 marketingFee ) external onlyOwner {...}","final_score":2.75,"mitigation":"The 'setTaxFee' function does not validate individual fee values except for their sum. An attacker with the DEFAULT_ADMIN_ROLE could set very high individual fee values that overflow when summed together, resulting in a low total fee due to overflow. This could be exploited to set extremely high fees and drain tokens during transfers.","title":"Unchecked Transfer"}]}